# 環境（Env）とは？

## 定義の復習

```hs
type Env = [(String, Int)]
```

これは「変数名とその値をペアにしたリスト」のこと

## 例：

```hs
[("x", 10), ("y", 7)]
```

このリストは：

- 変数 `x` の値は 10
- 変数 `y` の値は 7

という意味です。
環境 = 変数テーブルと捉えて OK です。

## なぜ必要なのか？

Haskell の `Expr` に `Var "x"` のような「変数」が出てくると、その「x って何？」を解決しなければなりません。

```hs
eval env (Var name) =
    case lookup name env of
        Just v -> v
        Nothing -> error $ "Unbound variable: " ++ name
```

ここで `lookup` は、`env` から `"x"` という文字列を検索して値を返します。
つまり：

> 「`x + 2 * y` を評価して」と言われたら、まず `x` と `y` に具体的な値が必要 → それが `Env`。

## Rust や C++ との違い

```rs
let x = 10;
let y = 7;
let result = x + 2 * y;
```

これはコンパイラが「x とは 10、y とは 7」と知っていて、即時に解決します。
→ つまり、Rust/C++では環境はスコープ（スタックやレジスタ）に隠されていて意識しない。

## 一方で、Haskell で DSL を書く場合：

DSL の評価関数を作ると、「変数とその値の対応表を明示的に持つ必要がある」のです。
→ これはインタプリタやスクリプト言語の評価器（eval）を書く際によくある設計です。

## まとめ

| 用語        | 意味                                          |
| ----------- | --------------------------------------------- |
| `Env`       | 変数名と値の対応（変数テーブル）              |
| `lookup`    | 文字列からその変数の値を取り出す              |
| Rust/C++    | スコープ・変数束縛はコンパイル時に隠蔽        |
| Haskell DSL | 自前で `Env` を管理して評価関数に渡す必要あり |

# 束縛とは？

Haskell において「束縛」は「名前と値の一度限りの対応」を意味します。

```hs
x = 3
```

この `x = 3` は「変数 `x` に 3 を束縛する」という意味であり、「代入」ではありません。

- 再代入はできない（x に後から別の値を設定することは不可）
- 一度束縛されたら、それは不変（immutable）

> 束縛 = 一回限りの定義（静的スコープで決まる）

# 環境とは？

環境は、評価のときに渡す動的な「変数マップ」です。

```hs
data Expr = Val Int | Var String | Add Expr Expr

type Env = [(String, Int)]

eval :: Env -> Expr -> Int
eval env (Var x) = case lookup x env of ...
```

ここでの `env` は：

- 「この評価時点で `x` はいくつか？」を決める
- Rust/C++で言えばスコープ内のローカル変数を lookup する感覚に近い

> 環境 = 評価時に変数名から値を探すマップ（動的な変数解決）

## 束縛 vs 環境の違い

| 概念        | 束縛（Binding）              | 環境（Environment）                              |
| ----------- | ---------------------------- | ------------------------------------------------ |
| 意味        | 変数に値を束縛する           | 変数名と値の対応表（評価用）                     |
| 対象        | ソースコード内で静的に決まる | 評価時に動的に渡される（インタプリタ的）         |
| 再代入      | 不可（一度きり）             | 可能（`Env` に複数バージョンを渡すこともできる） |
| 使用場所    | 通常の Haskell コード        | `eval` のような DSL・インタプリタの評価関数      |
| Rust 的対応 | `let x = 3;`（immutable）    | `HashMap<String, i32>` のようなスコープ表現      |

## 例で比較

### Haskell の通常コード（束縛）：

```hs
x = 3      -- 束縛
y = x + 5  -- 束縛を使った評価
```

ここでの `x` は束縛であり、再代入はできません。

### DSL 評価関数の中（環境）：

```hs
eval [("x", 3)] (Add (Var "x") (Val 5))  -- 8
```

ここで `x` の値は `Env` によって決まり、動的に変更可能です。

## まとめ

> Haskell では変数の再代入はない（束縛のみ）。
> しかし式の評価において「変数に値を対応付ける必要」があるとき、
> それを明示的に `Env` (環境) で渡して処理する。

つまり、環境とは「DSL 実装時に束縛の代わりに使う評価用の仕組み」です。
